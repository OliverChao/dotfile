{
  "init": {
    "prefix": "init",
    "description": "init a file",
    "body": [
      "package main",
      "",
      "import \"fmt\"",
      "$0",
      "func main() {",
      "\tfmt.Println(\"vim-go\")",
      "\\}"
    ],
    "luasnip": {
      "priority": -10
    }
  },
  "cf": {
    "prefix": "cf",
    "description": "codeforces init code",
    "body": [
      "package main",
      "",
      "import (",
      "\t\"bufio\"",
      "\t. \"fmt\"",
      "\t\"io\"",
      "\t\"os\"",
      ")",
      "",
      "func ${1:run}(_r io.Reader, _w io.Writer) {",
      "\tin := bufio.NewReader(_r)",
      "\tout := bufio.NewWriter(_w)",
      "\tdefer out.Flush()",
      "\t",
      "\tvar t int",
      "\tvar n int",
      "\tfor Fscan(in,&t);t>0;t--{",
      "\t\t$0",
      "\t\\}",
      "\\}",
      "",
      "func main() {",
      "\t$1(os.Stdin, os.Stdout)",
      "\\}"
    ]
  },
  "min": {
    "prefix": "min",
    "description": "min function",
    "body": [
      "func min(a, b ${1:int}) $1 {",
      "\tif a > b {",
      "\t\treturn b",
      "\t\\}",
      "\treturn a",
      "\\}$0"
    ]
  },
  "max": {
    "prefix": "max",
    "description": "max function",
    "body": [
      "func max(a, b ${1:int}) $1 {",
      "\tif a < b {",
      "\t\treturn b",
      "\t\\}",
      "\treturn a",
      "\\}$0"
    ]
  },
  "abs": {
    "prefix": "abs",
    "description": "abs function",
    "body": [
      "func abs(a ${1:int})$1{",
      "\tif  a<0{",
      "\t\treturn -a",
      "\t\\}",
      "\treturn a",
      "\\}$0"
    ]
  },
  "stringhash": {
    "prefix": "stringhash",
    "description": "string hash function",
    "body": [
      "hash := func(s string) {",
      "\t// 注意：由于哈希很容易被卡，能用其它方法实现尽量用其它方法",
      "\tconst prime uint64 = 1e8 + 7",
      "\tpowP := make([]uint64, len(s)+1) // powP[i] = prime^i",
      "\tpowP[0] = 1",
      "\tpreHash := make([]uint64, len(s)+1) // preHash[i] = hash(s[:i]) 前缀哈希",
      "\tfor i, b := range s {",
      "\t\tpowP[i+1] = powP[i] * prime",
      "\t\tpreHash[i+1] = preHash[i]*prime + uint64(b) // 本质是秦九韶算法",
      "\t\\}",
      "",
      "\t// 计算子串 s[l:r] 的哈希   0<=l<=r<=len(s)",
      "\t// 空串的哈希值为 0",
      "\tsubHash := func(l, r int) uint64 { return preHash[r] - preHash[l]*powP[r-l] \\}",
      "\t_ = subHash",
      "\\}",
      ""
    ]
  },
  ":": {
    "prefix": ":",
    "description": "v := value",
    "body": "$1 := $0"
  },
  "ap": {
    "prefix": "ap",
    "description": "append(slice, value)",
    "body": "append(${1:slice}, ${0:value})"
  },
  "ap=": {
    "prefix": "ap=",
    "description": "a = append(a, value)",
    "body": "${1:slice} = append($1, ${0:value})"
  },
  "br": {
    "prefix": "br",
    "description": "break",
    "body": "break"
  },
  "ch": {
    "prefix": "ch",
    "description": "chan Type",
    "body": "chan ${0:int}"
  },
  "con": {
    "prefix": "con",
    "description": "const XXX Type = ...",
    "body": "const ${1:NAME} ${2:Type} = ${0:0}"
  },
  "cons": {
    "prefix": "cons",
    "description": "const ( ... )",
    "body": [
      "const (",
      "\t${1:NAME} ${2:Type} = ${3:value}",
      ")"
    ]
  },
  "iota": {
    "prefix": "iota",
    "description": "const ( ... = iota )",
    "body": [
      "const (",
      "\t${1:NAME} ${2:Type} = iota",
      "\t$0",
      ")"
    ]
  },
  "cn": {
    "prefix": "cn",
    "description": "continue",
    "body": "continue"
  },
  "df": {
    "prefix": "df",
    "description": "defer someFunction()",
    "body": [
      "defer ${1:func}($2)",
      "$0"
    ]
  },
  "import": {
    "prefix": "import",
    "description": "import ( ... )",
    "body": [
      "import (",
      "\t\"${1:package}\"",
      ")"
    ]
  },
  "interface": {
    "prefix": "interface",
    "description": "interface I { ... }",
    "body": [
      "type ${1:Interface} interface {",
      "\t${2:/* TODO: add methods */}",
      "\\}"
    ]
  },
  "ew": {
    "prefix": "ew",
    "description": "errors.Wrap",
    "body": "errors.Wrap(${1:err}, \"${2:message}\")"
  },
  "ewf": {
    "prefix": "ewf",
    "description": "errors.Wrapf",
    "body": "errors.Wrapf(${1:err}, \"${2:message %v}\", ${3:args...})"
  },
  "errn": {
    "prefix": "errn",
    "description": "Error return",
    "body": [
      "if err != nil {",
      "\treturn err",
      "\\}",
      "$0"
    ]
  },
  "errnw": {
    "prefix": "errnw",
    "description": "Error return wrap",
    "body": [
      "if err != nil {",
      "\treturn errors.Wrap(err, \"${1:message}\")",
      "\\}",
      "$0"
    ]
  },
  "errnwf": {
    "prefix": "errnwf",
    "description": "Error return wrapf",
    "body": [
      "if err != nil {",
      "\treturn errors.Wrapf(err, \"${1:message %v}\", ${2:args...})",
      "\\}",
      "$0"
    ]
  },
  "errl": {
    "prefix": "errl",
    "description": "Error with log.Fatal(err)",
    "body": [
      "if err != nil {",
      "\tlog.Fatal(err)",
      "\\}",
      "$0"
    ]
  },
  "errn,": {
    "prefix": "errn,",
    "description": "Error return with two return values",
    "body": [
      "if err != nil {",
      "\treturn ${1:nil}, ${2:err}",
      "\\}",
      "$0"
    ]
  },
  "errn,w": {
    "prefix": "errn,w",
    "description": "Error return wrap with two return values",
    "body": [
      "if err != nil {",
      "\treturn nil, errors.Wrap(err, \"${1:message}\")",
      "\\}",
      "$0"
    ]
  },
  "errn,wf": {
    "prefix": "errn,wf",
    "description": "Error return wrapf with two return values",
    "body": [
      "if err != nil {",
      "\treturn nil, errors.Wrapf(err, \"${1:message %v}\", ${2:args...})",
      "\\}",
      "$0"
    ]
  },
  "errp": {
    "prefix": "errp",
    "description": "Error panic",
    "body": [
      "if err != nil {",
      "\tpanic($1)",
      "\\}",
      "$0"
    ]
  },
  "errt": {
    "prefix": "errt",
    "description": "Error test fatal ",
    "body": [
      "if err != nil {",
      "\tt.Fatal(err)",
      "\\}",
      "$0"
    ]
  },
  "errh": {
    "prefix": "errh",
    "description": "Error handle and return",
    "body": [
      "if err != nil {",
      "\t$1",
      "\treturn",
      "\\}",
      "$0"
    ]
  },
  "ft": {
    "prefix": "ft",
    "description": "fallthrough",
    "body": "fallthrough"
  },
  "forsel": {
    "prefix": "forsel",
    "description": "for select",
    "body": [
      "for {",
      "\tselect {",
      "\t\tcase ${2:${1:result} := }<- ${3:channel}:",
      "\t\t\t$0",
      "\t\\}",
      "\\}"
    ]
  },
  "selc": {
    "prefix": "selc",
    "description": "select case",
    "body": [
      "case ${1:${2:var} := }<-${3:channel}:",
      "$0"
    ]
  },
  "make": {
    "prefix": "make",
    "description": "make(Type, size)",
    "body": "make(${1:[]string}, ${2:0})$0"
  },
  "map": {
    "prefix": "map",
    "description": "map[Type]Type",
    "body": "map[${1:string}]${0:int}"
  },
  "package": {
    "prefix": "package",
    "description": "package ...",
    "body": [
      "// Package $1 provides ${2:...}",
      "package ${1:main}",
      "$0"
    ]
  },
  "select": {
    "prefix": "select",
    "description": "select { case a := <-chan: ... }",
    "body": [
      "select {",
      "case ${1:v1} := <-${2:chan1}:",
      "\t$0",
      "\\}"
    ]
  },
  "st": {
    "prefix": "st",
    "description": "type T struct { ... }",
    "body": [
      "type ${1:Type} struct {",
      "\t$0",
      "\\}"
    ]
  },
  "switch": {
    "prefix": "switch",
    "description": "switch x { ... }",
    "body": [
      "switch ${1:var} {",
      "case ${2:value1}:",
      "\t$0",
      "\\}"
    ]
  },
  "tswitch": {
    "prefix": "tswitch",
    "description": "type switch x { ... }",
    "body": [
      "switch ${2:$1 := }${1:v}.(type) {",
      "\t$0",
      "\\}"
    ]
  },
  "sp": {
    "prefix": "sp",
    "description": "fmt.Sprintf(...)",
    "body": "fmt.Sprintf(\"%${1:s}\", ${2:var})"
  },
  "go": {
    "prefix": "go",
    "description": "go someFunc(...)",
    "body": "go ${1:funcName}($0)"
  },
  "tr": {
    "prefix": "tr",
    "description": "t.Run(XYZ, func(t *testing.T){ ... })",
    "body": [
      "t.Run(\"$0\", func(t *testing.T){",
      "",
      "\\})"
    ]
  },
  "hf": {
    "prefix": "hf",
    "description": "http.HandlerFunc",
    "body": [
      "func ${1:handler}(w http.ResponseWriter, r *http.Request) {",
      "\t${0:fmt.Fprintf(w, \"hello world\")}",
      "\\}"
    ]
  },
  "hhf": {
    "prefix": "hhf",
    "description": "mux.HandleFunc",
    "body": [
      "${1:http}.HandleFunc(\"${2:/}\", func(w http.ResponseWriter, r *http.Request) {",
      "\t${0:fmt.Fprintf(w, \"hello world\")}",
      "\\})"
    ]
  },
  "ter": {
    "prefix": "ter",
    "description": "if err != nil { t.Errorf(...) }",
    "body": [
      "if err != nil {",
      "\tt.Errorf(\"${0:message}\")",
      "\\}"
    ]
  },
  "terf": {
    "prefix": "terf",
    "description": "if err != nil { t.Fatalf(...) }",
    "body": [
      "if err != nil {",
      "\tt.Fatalf(\"${0:message}\")",
      "\\}"
    ]
  },
  "var": {
    "prefix": "var",
    "description": "var x Type [= ...]",
    "body": "var ${1:x} ${2:Type}${3: = ${0:value}}"
  },
  "vars": {
    "prefix": "vars",
    "description": "var ( ... )",
    "body": [
      "var (",
      "\t${1:x} ${2:Type}${3: = ${0:value}}",
      ")"
    ]
  },
  "eq": {
    "prefix": "eq",
    "description": "equals: test two identifiers with DeepEqual",
    "body": [
      "if !reflect.DeepEqual(${1:expected}, ${2:actual}) {",
      "\t_, file, line, _ := runtime.Caller(0)",
      "\tfmt.Printf(\"%s:%d:\\n\\n\\texp: %#v\\n\\n\\tgot: %#v\\n\\n\", filepath.Base(file), line, $1, $2)",
      "\tt.FailNow()",
      "\\}"
    ]
  },
  "uf2": {
    "prefix": "uf2",
    "description": "DSU; inline",
    "body": [
      "var fa []int",
      "var get func(x int) int",
      "get = func(x int) int {",
      "\tif fa[x] == x {",
      "\t\treturn x",
      "\t\\}",
      "\tfa[x] = get(fa[x])",
      "\treturn fa[x]",
      "\\}",
      "merge := func(x, y int) {",
      "\tfa[get(x)] = get(y)",
      "\\}"
    ]
  },
  "uf": {
    "prefix": "uf",
    "description": "DSU",
    "body": [
      "type UF struct {",
      "\tparents []int",
      "\tsize    []int",
      "\\}",
      "",
      "func (u *UF) init(n int) {",
      "\tu.parents = make([]int, n)",
      "\tu.size = make([]int, n)",
      "\tfor i := range u.parents {",
      "\t\tu.parents[i] = i",
      "\t\tu.size[i] = 1",
      "\t\\}",
      "\\}",
      "",
      "func (u *UF) find(x int) int {",
      "\tfor u.parents[x] != x {",
      "\t\tu.parents[x] = u.parents[u.parents[x]]",
      "\t\tx = u.parents[x]",
      "\t\\}",
      "\treturn x",
      "\\}",
      "",
      "func (u *UF) union(a, b int) {",
      "\tpa := u.find(a)",
      "\tpb := u.find(b)",
      "\tif pa == pb {",
      "\t\treturn",
      "\t\\}",
      "\tif u.size[pa] < u.size[pb] {",
      "\t\tpa, pb = pb, pa",
      "\t\\}",
      "\tu.parents[pb] = pa",
      "\tu.size[pa] += u.size[pb]",
      "\\}",
      "",
      "func (u *UF) connected(a, b int) bool {",
      "\treturn u.find(a) == u.find(b)",
      "\\}"
    ]
  }
}
